
use std::marker::PhantomData;
use std::ops::Deref;
use std::ops::DerefMut;
use std::iter::DoubleEndedIterator;

// The Id struct is a phantom type that is used to ensure that the Indexer and Indices structs
type Id<'id> = PhantomData<::std::cell::Cell<&'id mut ()>>;  

// The Indexer struct holds a reference to an array and a lifetime marker.
pub struct Indexer<'id, Array, T> {
    _id: Id<'id>,
    arr: Array,
    _marker: PhantomData<T>,
}

pub struct IndexerMut<'id, Array: DerefMut<Target=[T]>, T> { 
    _id: Id<'id>,
    _marker: PhantomData<T>,
    arr: Array, 
}

pub struct IndexerDeref<'id, Array: Deref<Target=[T]>, T> { 
    _id: Id<'id>,
    _marker: PhantomData<T>,
    arr: Array,
}

impl<'id, Array: Deref<Target=[T]>, T> Indexer<'id, Array, T> {
    pub(crate) fn id(&self) -> Id<'id> { self._id }
    pub(crate) fn into_inner(self) -> Array { self.arr }
}

impl<'id, Array: Deref<Target=[T]>, T> Indexer<'id, Array, T> {
    pub(crate) fn new(arr: Array) -> Self { Indexer { _id: PhantomData, _marker: PhantomData, arr } }
    pub(crate) fn with_id(arr: Array, _id: Id<'id>) -> Self { Indexer { _id, _marker: PhantomData, arr } }
    pub(crate) fn as_inner(&self) -> &Array { &self.arr }    
}

impl<'id, Array: DerefMut<Target=[T]>, T> IndexerMut<'id, Array, T> {
    pub(crate) fn new(arr: Array) -> Self { IndexerMut { _id: PhantomData, _marker: PhantomData, arr } }
    pub(crate) fn with_id(arr: Array, _id: Id<'id>) -> Self { IndexerMut { _id, _marker: PhantomData, arr } }    
    pub(crate) fn as_inner_mut(&mut self) -> &mut Array { &mut self.arr }
}

// The Indices struct holds the range of valid indices for the array. These indices are
// used to create the Index struct. They are generated by the indices function.
// TODO: Make this a range instead of a struct.
pub struct Indices<'id> {
    _id: Id<'id>,
    min: usize,
    max: usize,
}

// The Index struct represents a valid index into the array.
#[derive(Copy, Clone)]
pub struct Index<'id> { 
    _id: Id<'id>,
    idx: usize,
}

impl<'id> Index<'id> {
    pub fn new(idx: usize) -> Self { 
        Index { 
            _id: PhantomData,
            idx 
        }        
    }
}

// The Indexer can retrieve a reference to an element in the array.
impl<'id, 'a, T> Indexer<'id, &'a [u32], T> {
    pub fn idx(&self, idx: Index<'id>) -> &'a u32 {

        // The unsafe block is needed because the compiler can't 
        // prove that the index is valid. We know it is because we
        // are using the Indexer struct to get the index, and we
        // ensure lifetime safety by using the Id struct.
        unsafe { self.arr.get_unchecked(idx.idx) }
        // ------------------------------------------------- //
        // SAFE: The index is valid because we are using the //
        // Indexer struct to get the index.                  //

    }
}

impl<'id, 'a, T> Indexer<'id, &'a [T], T> {

    // We can get a reference to an element in the array. From there we can get a reference
    // to the underlying array. 
    pub fn get(&self, idx: Index<'id>) -> Option<&'a T> { 

        match self.arr.get(idx.idx) {
            Some(x) => Some(x),
            None => None,
        }
    }
}

// The Indices struct can be used as an iterator over the valid indices. 
impl<'id> Iterator for Indices<'id> {
    type Item = Index<'id>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.min != self.max {
            self.min += 1;
            Some(Index { _id: PhantomData, idx: self.min - 1 })
        } else {
            None
        }
    }
}

// The Indices struct can also be used as a double-ended iterator.
impl<'id> DoubleEndedIterator for Indices<'id> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.min != self.max {
            self.max -= 1;
            Some(Index { _id: PhantomData, idx: self.max })
        } else {
            None
        }
    }
}

// indexers can be dereferenced to the underlying array
impl<'id, Array: Deref<Target=[T]>, T> Deref for Indexer<'id, Array, T> {
    type Target = [T];
    fn deref(&self) -> &Self::Target { &self.arr }
}


// The indices function takes an array and a function, and applies the function to the array
// and its valid indices.
pub fn indices<Array, F, Out, T>(arr: Array, f: F) -> Out
    where F: for<'id> FnOnce(Indexer<'id, Array, T>, Indices<'id>) -> Out,
            Array: Deref<Target = [u32]>,
{

    let len = arr.len();
    let indexer: Indexer<'_, Array, T> = Indexer { _id: PhantomData, arr: arr, _marker: PhantomData };
    let indices: Indices<'_> = Indices { _id: PhantomData, min: 0, max: len };
    f(indexer, indices)
}



// Recursive type (because we can) 
pub enum Rec<'a, T> { 
    Nil,
    Cons( T, &'a Rec<'a, T>, &'a Rec<'a, T> ),
}
impl<'a, T> Rec<'a, T> {

    // Create a new empty list.
    pub fn new() -> Self { Rec::Nil }
    
    
    pub fn cons(&'a self, x: T) -> Self {
        Rec::Cons(x, self, self)  
    }
    pub fn head(&self) -> Option<&T> {  
        match self {
            Rec::Nil => None,
            Rec::Cons(x, _, _) => Some(x),
        }
    }
    pub fn tail(&self) -> Option<&Self> {  
        match self {
            Rec::Nil => None,
            Rec::Cons(_, x, _) => Some(x),
        }
    }
    pub fn tail2(&self) -> Option<&Self> {
        match self {
            Rec::Nil => None,
            Rec::Cons(_, _, x) => Some(x),
        }
    }
}







pub trait Sliceable: Sized { type Slice<'a>: AsRef<[Self]> where Self: 'a;
    // 
    fn get_slice<'b>(&'b self) -> &'b Self::Slice<'b>;
}
struct MyStruct {
    x: Vec<i32>,
    y: Vec<i32>,
}
impl AsRef<[i32]> for &MyStruct {
    fn as_ref(&self) -> &[i32] {
        &self.x
    }
}

pub fn my_struct() {
    let my_struct = MyStruct {
        x: vec![1, 2, 3],
        y: vec![4, 5, 6],
    };
}

pub fn with_last_item<S: Sliceable, F: FnOnce(Option<&S>)>(item: &S, f: F)
where
    for<'a> S::Slice<'a>: AsRef<[S]>, 
{
    let binding: &S::Slice<'_> = item.get_slice();   
    let slice: &[S] = binding.as_ref() as &[S];

    let last_item = match slice {
        [.., last] => Some(last),
        [] => None,
    };
    f(last_item);
}





#[cfg(test)]
mod unit_tests {

    use super::*;
    #[test]
    fn test_all() {
        // use indexing::indices;
    
        let arr1: &[u32] = &[1, 2, 3, 4, 5];
     
        // can hold onto the indices for later, as long they stay in the closure
        let _a = indices(arr1, |arr: Indexer<'_, &[u32], u32>, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
    
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        });
    
        // can get references out, just not indices
        let (x, y) = indices(arr1, |arr: Indexer<'_, &[u32], u32>, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        });
        assert!(x == &1 && y == &5);
    
    }

}



#[cfg(test)]
mod this_test4 {

    use super::*;


    #[test]
    fn test_indices<'a>() {
        // use indexing::indices;
    
        let arr1: &[u32] = &[1, 2, 3, 4, 5];
        let arr2: &[u32] = &[1, 2, 3, 4, 5, 6];

        let mut it = indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            (arr.get(a).unwrap(), arr.get(b).unwrap()) 
        });
        let x = it.0;
        let y = it.1;
        assert!(x == &1 && y == &5);
        assert_eq!(indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        }), (&1, &5));

        let (x, y) = indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            (arr.get(a).unwrap(), arr.get(b).unwrap())
            
        });
        assert!(x == &1 && y == &5);
        assert_eq!(indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        }), (&1, &5));

    }



    fn test_all() {
        // use indexing::indices;
    
        let arr1: &[u32] = &[1, 2, 3, 4, 5];
        let arr2: &[u32] = &[10, 20, 30];
    
        // concurrent iteration 
        indices(arr1, |arr1, it1| {
            indices(arr2, move |arr2, it2| {
                for (i, j) in it1.zip(it2) {
                    let check_1 = arr1.get(i).unwrap() + arr2.get(j).unwrap() == 11;
                    let check_2 = arr1.get(i).unwrap() + arr2.get(j).unwrap() == 21;
                    assert!(check_1 || check_2); 
                }
            });
        });

        assert!(arr1.iter().sum::<u32>() == 15);
    
        // can hold onto the indices for later, as long they stay in the closure
        let _a = indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
    
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        });
    
        // can get references out, just not indices
        let (x, y) = indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        });
        assert!(x == &1 && y == &5);
    
    }

}

#[test]
fn test_6() {


    let arr1: &[u32] = &[1, 2, 3, 4, 5];
    let arr2: &[u32] = &[10, 20, 30];

    // Concurrent iteration over two arrays.
    indices(arr1, |arr1: Indexer<'_, &[u32], u32>, it1| {
        indices(arr2, move |arr2: Indexer<'_, &[u32], u32>, it2| {
            for (i, j) in it1.zip(it2) {
                println!("{:?} {:?}", arr1.get(i), arr2.get(j));
            }
        });
    });

    // Holding onto indices for later use.
    let _a = indices(arr1, |arr: Indexer<'_, &[u32], u32>, mut it| {
        let a = it.next().unwrap();
        let b = it.next_back().unwrap();
        println!("{:?} {:?}", arr.get(a), arr.get(b));
    });

    // Getting references out of the array.
    let (x, y) = indices(arr1, |arr: Indexer<'_, &[u32], u32>, mut it| {
        let a = it.next().unwrap();
        let b = it.next_back().unwrap();
        (arr.get(a), arr.get(b))
    });
    println!("{:?} {:?}", x, y);
}