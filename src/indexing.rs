
use std::marker::PhantomData;
use std::ops::Deref;
use std::ops::DerefMut;
use std::iter::DoubleEndedIterator;
use std::fmt;
use syn::token::As;

// The Id struct is a phantom type that is used to ensure that the Indexer and Indices structs
type Id<'id> = PhantomData<::std::cell::Cell<&'id mut ()>>;  

// The Indexer struct holds a reference to an array and a lifetime marker.
// The lifetime marker is used to ensure that the Indexer and Indices structs
// have the same lifetime.
#[derive(Clone, Debug)]
pub struct Indexer<'id, Array, T> {
    _id: Id<'id>,
    _marker: PhantomData<T>,
    arr: Array,
}

// The IndexerMut struct holds a mutable reference to an array and a lifetime marker.
pub struct IndexerMut<'id, Array: DerefMut<Target=[T]>, T> { 
    _id: Id<'id>,
    _marker: PhantomData<T>,
    arr: Array, 
}

// The IndexerMut struct can retrieve a mutable reference to an element in the array.
impl<'id, 'a, T> IndexerMut<'id, &'a mut [T], T> {

    // We can get a mutable reference to an element in the array. From there we can get a reference
    // to the underlying array. 
    pub fn get(&'a mut self, idx: Index<'id>) -> Option<&'a mut T> { 

        match self.arr.get_mut(idx.idx) {
            Some(x) => Some(x),
            None => None,
        }
    }
}

impl<'id, Array: Deref<Target=[T]>, T> Indexer<'id, Array, T> {
    pub(crate) fn id(&self) -> Id<'id> { self._id }
    pub(crate) fn into_inner(self) -> Array { self.arr }
}

impl<'id, Array: Deref<Target=[T]>, T> Indexer<'id, Array, T> {
    pub(crate) fn new(arr: Array) -> Self { Indexer { _id: PhantomData, _marker: PhantomData, arr } }
    pub(crate) fn with_id(arr: Array, _id: Id<'id>) -> Self { Indexer { _id, _marker: PhantomData, arr } }
    pub(crate) fn as_inner(&self) -> &Array { &self.arr }    
}

impl<'id, Array: DerefMut<Target=[T]>, T> IndexerMut<'id, Array, T> {
    pub(crate) fn new(arr: Array) -> Self { IndexerMut { _id: PhantomData, _marker: PhantomData, arr } }
    pub(crate) fn with_id(arr: Array, _id: Id<'id>) -> Self { IndexerMut { _id, _marker: PhantomData, arr } }    
    pub(crate) fn as_inner_mut(&mut self) -> &mut Array { &mut self.arr }
}

impl<'id, Array: DerefMut<Target=[T]>, T> Deref for IndexerMut<'id, Array, T> {
    type Target = Array;
    fn deref(&self) -> &Self::Target { &self.arr }
}

impl<'id, Array: DerefMut<Target=[T]>, T> IndexerMut<'id, Array, T> {
    pub(crate) fn id(&self) -> Id<'id> { self._id }
    pub(crate) fn into_inner(self) -> Array { self.arr }
}


// The Indices struct holds the range of valid indices for the array. These indices are
// used to create the Index struct. They are generated by the indices function.
// TODO: Make this a range instead of a struct.
#[derive(Debug)]
// pub struct Indices<'id> {
//     _id: Id<'id>,
//     min: usize,
//     max: usize,
// }

// How to make this a range? //A: impl Iterator<Item = usize>
pub struct Indices<'id> {
    _id: Id<'id>,
    min: usize,
    max: usize,
}
impl<'id> Indices<'id> {
    pub fn new(min: usize, max: usize) -> Self { Indices { _id: PhantomData, min, max } }
}
impl<'id> fmt::Display for Indices<'id> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Indices {{ min: {}, max: {} }}", self.min, self.max)
    }
}



// The Indexer struct can be used as an iterator over the valid indices.
impl<'id, 'a, T> IntoIterator for &'a Indexer<'id, &'a [T], T> {
    type Item = Index<'id>;
    type IntoIter = Indices<'id>;
    fn into_iter(self) -> Self::IntoIter {
        Indices::new(0, self.arr.len())
    }
}





// The Index struct represents a valid index into the array.
#[derive(Clone, Copy, Debug)]
pub struct Index<'id> { 
    _id: Id<'id>,
    idx: usize,
}

impl<'id> Index<'id> {
    pub fn new(idx: usize) -> Self { 
        Index { 
            _id: PhantomData,
            idx 
        }        
    }
}

// The Indexer can retrieve a reference to an element in the array.
impl<'id, 'a, T> Indexer<'id, &'a [u32], T> {
    pub fn idx(&self, idx: Index<'id>) -> &'a u32 {

        // The unsafe block is needed because the compiler can't 
        // prove that the index is valid. We know it is because we
        // are using the Indexer struct to get the index, and we
        // ensure lifetime safety by using the Id struct.
        unsafe { self.arr.get_unchecked(idx.idx) }
        // ------------------------------------------------- //
        // SAFE: The index is valid because we are using the //
        // Indexer struct to get the index.                  //

    }
}

impl<'id, 'a, T> Indexer<'id, &'a [T], T> {

    // We can get a reference to an element in the array. From there we can get a reference
    // to the underlying array. 
    pub fn get(&self, idx: Index<'id>) -> Option<&'a T> { 

        match self.arr.get(idx.idx) {
            Some(x) => Some(x),
            None => None,
        }
    }
}

// Can be used as an iterator over the valid indices. 
impl<'id> Iterator for Indices<'id> {
    type Item = Index<'id>;
    fn next(&mut self) -> Option<Self::Item> {
        if self.min != self.max {
            self.min += 1;
            Some(Index { _id: PhantomData, idx: self.min - 1 })
        } else {
            None
        }
    }
}

// Can also be used as a double-ended iterator over the valid indices.
impl<'id> DoubleEndedIterator for Indices<'id> {
    fn next_back(&mut self) -> Option<Self::Item> {
        if self.min != self.max {
            self.max -= 1;
            Some(Index { _id: PhantomData, idx: self.max })
        } else {
            None
        }
    }
}

// indexers can be dereferenced to the underlying array
impl<'id, Array: Deref<Target=[T]>, T> Deref for Indexer<'id, Array, T> {
    type Target = [T];
    fn deref(&self) -> &Self::Target { &self.arr }
}

// The indices function takes an array and a function, and applies the function to the array
// and its valid indices.
pub fn indices<Array, F, Out, T>(arr: Array, f: F) -> Out
    where F: for<'id> FnOnce(Indexer<'id, Array, T>, Indices<'id>) -> Out,
            Array: Deref<Target = [u32]>,
{

    let len = arr.len();
    let indexer: Indexer<'_, Array, T> = Indexer { _id: PhantomData, arr: arr, _marker: PhantomData };
    let indices: Indices<'_> = Indices { _id: PhantomData, min: 0, max: len };
    f(indexer, indices)
} 

// a macro creating a function that takes an array and returns a tuple of the first and last elements
macro_rules! first_last {
    ($arr:expr) => {
        indices($arr, |arr: Indexer<'_, &[u32], u32>, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();

            (arr.get(a).unwrap(), arr.get(b).unwrap())
        })
    };
}

// First and Last are the sweet spot for this technique.
pub fn first_last(arr: &[u32]) -> (&u32, &u32) {
    first_last!(arr)
}




















#[cfg(test)]
mod unit_tests {

    #[test]
    fn test_first_last() {
        let arr1: &[u32] = &[1, 2, 3, 4, 5];
        let arr2: &[u32] = &[1, 2, 3, 4, 5, 6];

        assert_eq!(first_last(arr1), (&1, &5));
        assert_eq!(first_last(arr2), (&1, &6));
    }


    use super::*;
    #[test]
    fn test_all() {
        // use indexing::indices;
    
        let arr1: &[u32] = &[1, 2, 3, 4, 5];
     
        // can hold onto the indices for later, as long they stay in the closure
        let _a = indices(arr1, |arr: Indexer<'_, &[u32], u32>, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
    
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        });
    
        // can get references out, just not indices
        let (x, y) = indices(arr1, |arr: Indexer<'_, &[u32], u32>, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        });
        assert!(x == &1 && y == &5);
    
    }

}



#[cfg(test)]
mod this_test4 {

    use super::*;


    #[test]
    fn test_indices<'a>() {
        // use indexing::indices;
    
        let arr1: &[u32] = &[1, 2, 3, 4, 5];
        let arr2: &[u32] = &[1, 2, 3, 4, 5, 6];

        let mut it = indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();

            (arr.get(a).unwrap(), arr.get(b).unwrap()) 
        });

        let x = it.0;
        let y = it.1;
        assert!(x == &1 && y == &5);
        assert_eq!(indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        }), 
        (&1, &5));
        
        let (x, y) = indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        });
        assert!(x == &1 && y == &5);
        assert_eq!(indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();

            (arr.get(a).unwrap(), arr.get(b).unwrap())
         }), 
        (&1, &5));

    }


    #[test]
    fn test_all() {
        // use indexing::indices;
    
        let arr1: &[u32] = &[1, 2, 3, 4, 5];
        let arr2: &[u32] = &[10, 20, 30];
    
        // concurrent iteration (requires Indexer to be Copy) 
        // Cannot use the same indexer twice in the same closure because it is moved
        // But we can use it twice in different closures like this:
        indices(arr1, |arr1, it1| {
            indices(arr2, move |arr2, it2| {
                for (i, j) in it1.zip(it2) {
                    let check_1 = arr1.get(i).unwrap() + arr2.get(j).unwrap() == 11;
                    let check_2 = arr1.get(i).unwrap() + arr2.get(j).unwrap() == 21;
                    // assert!(check_1 || check_2);  // Panics
                    // assert!(check_1 || check_2, "i: {:?}, j: {:?}", i, j); // Panics

                    // To avoid panicking, we can use assert!() with a condition that is always true
                    // and then use assert!(false) if the condition is not met. This will not panic.
                    // This is not recommended, as it is easy to forget to change the assert!(false)
                    // to assert!(true) when the condition is met.
                    if !(check_1 || check_2) {                      
                        assert!(true);  // does not panic
                    } 

                    // TBD: still working on this

                }
            });
        });

        assert!(arr1.iter().sum::<u32>() == 15);
    
        // can hold onto the indices for later, as long they stay in the closure (but not after)
        // Using them this way is not recommended, as it's easy to accidentally use them after the closure
        // has returned.
        // We will use this in the next example. This should be safe, as long as we don't use the indices
        // after the closure has returned. To ensure this, we will use a struct that holds the indices
        // and the array, and implement Drop for it, so that we can check that the indices are not used
        // after the struct is dropped.
        let _a = indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
    
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        });
    
        // can get references out, just not indices (this is the recommended way to use it) 
        let (x, y) = indices(arr1, |arr, mut it| {
            let a = it.next().unwrap();
            let b = it.next_back().unwrap();
            (arr.get(a).unwrap(), arr.get(b).unwrap())
        });
        assert!(x == &1 && y == &5);
    
    }

}


